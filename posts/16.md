---
Title: Why bother about productivity?
Date: 2015-02-11
Author: Priyanka Sharma
AuthorUrl: https://twitter.com/pritianka
AuthorGravatar: https://1.gravatar.com/avatar/8a40c795faff113fd90dbda994d43156
---

<p style="text-align:center;">
    <img src="https://wakatime.com/static/img/blog/productive-definition.png" alt="Productive Definition" title="Productive Definition" style="width:100%;" />
</p>
_Merriam Webster Dictionary_

Bang for buck on life. Knowing you made the best use of your hours frees up the rest of your day to do whatever you please.
Also, as a software developer, life is as much about renewing your skill set as it is about executing on tasks.
To learn the smart way, your process needs to work.
Else, you will either fall behind, or you will spend 2-3x the time you should learning.
When it comes to individuals, it's not about completing features but rather about accomplishing personal goals.
These goals can be finishing a feature set, or they can be bug fixing, learning a new framework, etc.  

### Individual programmers are not good at measuring their productivity.

Independent contractors, the type of people who tend to use WakaTime's analytics the most, are the best in class when it comes to studying their performance and creating workflows that make them ninjas of software development.
Taking their example, I formulated a simple productivity score for my development work.  

<p style="text-align:center;">
    <img src="https://wakatime.com/static/img/blog/productivity-formula.png" alt="Productivity Formula" title="Productivity Formula" style="width:100%;" />
</p>

_* where 1 is the easiest level of difficulty._

The lower the number, the better I did. This formula applies when measuring productivity for an individual shaped in the values of team productivity.
You get to see how quickly I finished said task weighted for how hard it is.

If, however, the question is not about a deployable feature, the formula fails.
It is possible to assign a difficulty level to any task, not just a story.
But when covering uncharted territory, I find myself stooping to wild guesswork when estimating difficulty.
As a result, the number becomes phenomenally unreliable.

In those circumstances, I make it really simple.
In my coding I find that focused time is better than fragmented.
So I check how many hours of uninterrupted work I did.
For my projects, I found graphs that looked like this

<p style="text-align:center; margin-bottom:0;">
    <img src="https://wakatime.com/static/img/blog/chart-single-day-good.png" alt="productive day" title="productive day" class="img-thumbnail" />
</p>
<p style="text-align:right; font-size:10px; color:#777;"><i>powered by <a href="https://wakatime.com">WakaTime</a></i></p>

were much better days than graphs that looked like 

<p style="text-align:center; margin-bottom:0;">
    <img src="https://wakatime.com/static/img/blog/chart-single-day-bad.png" alt="unproductive day" title="unproductive day" class="img-thumbnail" />
</p>
<p style="text-align:right; font-size:10px; color:#777;"><i>powered by <a href="https://wakatime.com">WakaTime</a></i></p>


So if you are looking for prowess metrics in software development, measure the time you spend programming and the distribution of those hours.
I personally found a commitment of 90 minute sessions interrupted by breaks <= 5 minutes were best.

What's your story?  Have you found some good ways to track yourself?
